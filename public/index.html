<html>
	<head>
		<title>orbit</title>
		<script>
			var requestAnimFrame = (function(){
			      return  window.requestAnimationFrame       || 
			              window.webkitRequestAnimationFrame || 
			              window.mozRequestAnimationFrame    || 
			              window.oRequestAnimationFrame      || 
			              window.msRequestAnimationFrame     || 
			              function(callback) {
			              		window.setTimeout(callback, 1000 / 60);
			              };
			})();

			// Array Remove - By John Resig (MIT Licensed)
			Array.prototype.remove = function(from, to) {
				var rest = this.slice((to || from) + 1 || this.length);
				this.length = from < 0 ? this.length + from : from;
				return this.push.apply(this, rest);
			};

			var GameState = {
				ORBIT_PLACING : 1,
				ORBIT_WINDUP : 2,
				ORBIT_ACTIVE : 3,
				ORBIT_FINISHED : 4
			};

			// Game variables.
			var gameState;
			var planetsLeft;
			var mousePos;
			var mouseDownPos;
			var maxLength;
			var maxDistance;
			var iterations;

			// Initialize the game objects.
			var thrownObject;
			var thrownObjects;

			var planet = {
				radius : 50,
				pos : [ 0, 0 ],
				img : null
			};

			function drawOrbitPosition(context, pos, radius) {
				context.fillStyle = "#ec4343";
				context.strokeStyle = "#00bff3";

				context.beginPath();
				context.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, false);
				context.fill();
				context.stroke();
			}

			function length(vec) {
				return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
			}

			function distance(vec1, vec2) {
				var x = vec2[0] - vec1[0];
				var y = vec2[1] - vec1[1];
				return length([x, y]);
			}
			function normalize(vec) {
				var len = length(vec);
				return [ vec[0] / len, vec[1] / len ];
			}

			function direction(vec1, vec2) {
				var x = vec2[0] - vec1[0];
				var y = vec2[1] - vec1[1];
				return normalize([ x, y ]);
			}

			function update() {
				if (gameState == GameState.ORBIT_PLACING) {
					thrownObject.pos = mousePos;
				}
				else if (gameState == GameState.ORBIT_WINDUP) {
					thrownObject.pos = mouseDownPos;
				}

				if (planetsLeft <= 0) {
					// TODO: Some other mode here of showing the score. This is a big state change.
					initializeGameVars();
				}

				var activeObjects = 0;

				for (var i = 0; i < thrownObjects.length; ++i) {
					var obj = thrownObjects[i];
					if (obj.active == false) {
						continue;
					}

					activeObjects++;

					var curPos = obj.pos;
					var curVel = obj.vel;
					var planetPos = planet.pos;

					var dist = distance(curPos, planetPos);
					var dir = direction(curPos, planetPos);
					var force = 3000.0 / ((dist * dist) + 500.0);

					if (dist > maxDistance) {
						obj.active = false;
					}

					curVel[0] += dir[0] * force;
					curVel[1] += dir[1] * force;

					curPos[0] += curVel[0];
					curPos[1] += curVel[1];

					// Cheat here a little bit to make the mechanics more interesting.
					// Basically, don't allow the distance from the planet to exceed the prior distance.
					// This forces the orbit into a spiral, but avoids the ease of putting the object into
					// an elliptical orbit, rewarding more circular orbits.
					// TODO: Kill the component velocity away from the planet.
					var newDist = distance(curPos, planetPos);
					if (newDist > dist) {
						var nDir = direction(planetPos, curPos);
						curPos[0] = planetPos[0] + nDir[0] * dist; 
						curPos[1] = planetPos[1] + nDir[1] * dist;
					}

					var collideDist = distance(curPos, planetPos);
					if (collideDist < obj.radius + planet.radius) {
						obj.active = false;
						planetsLeft -= 1;
						// TODO: Some sweet effect here.
					}

					if (obj.active) {
						for (var j = 0; j < thrownObjects.length; ++j) {
							var obj2 = thrownObjects[j];
							if (obj2.active && obj != obj2) {
								var collideDist = distance(obj.pos, obj2.pos);
								if (collideDist < obj.radius + obj2.radius) {
									obj.active = false;
									obj2.active = false;
									planetsLeft -= 2;
								}
							}
						}
					}
				}

				if (iterations > 5) {
					var scoreContainer = document.getElementById('scoreContainer');
					if (activeObjects > 0 && parseFloat(scoreContainer.style.opacity) == 0) {
						fadeIn(scoreContainer);
					}

					var score = document.getElementById('highScore');
					score.innerHTML = activeObjects.toFixed(0);

					var planets = document.getElementById('planetsLeft');
					planets.innerHTML = planetsLeft.toFixed(0);

					iterations = 0;
				}
				iterations++;
			}

			function fadeIn(element) {
				var interval = window.setInterval(function() {
 					var opacity = parseFloat(element.style.opacity);
 					var newOpacity = (opacity + 0.025).toFixed(2);
 					element.style.opacity = newOpacity;

 					if (newOpacity >= 1.0) {
 						window.clearInterval(interval);
 					}
 				}, 33);
			}

			function draw(context) {
				var canvas = document.getElementById('gameBoard');
				var width = window.innerWidth;
 				var height = window.innerHeight;
				context.clearRect(0, 0, width, height);

				if (gameState == GameState.ORBIT_WINDUP) {
					context.strokeStyle = "#ffffff";

					var dir = direction(mousePos, mouseDownPos);
					var dist = Math.min(distance(mousePos, mouseDownPos), maxLength);
					var endPos = [ mouseDownPos[0] + dir[0] * dist, mouseDownPos[1] + dir[1] * dist ];

					context.lineWidth = 3;
					context.moveTo(mouseDownPos[0], mouseDownPos[1]);
					context.lineTo(endPos[0], endPos[1]);
					context.stroke();
				}

				context.fillStyle = "#ec4343";
				context.strokeStyle = "#00bff3";

				context.lineWidth = 2;
				if (thrownObject) {
					drawOrbitPosition(context, thrownObject.pos, thrownObject.radius);
				}

				for (var i = 0; i < thrownObjects.length; ++i) {
					var obj = thrownObjects[i];
					if (obj.active) {
						drawOrbitPosition(context, obj.pos, obj.radius);
					}
				}

				if (planet.img) {
					context.drawImage(planet.img, planet.pos[0] - planet.img.width / 2, planet.pos[1] - planet.img.height / 2);
				}
			}

			function handleMouseMove(mouseMoveEvent) {
				var x, y;
				if (mouseMoveEvent.layerX || mouseMoveEvent.layerX == 0) {
					x = mouseMoveEvent.layerX;
					y = mouseMoveEvent.layerY;
				}
				else if (mouseMoveEvent.offsetX || mouseMoveEvent.offsetX == 0) {
				    x = ev.offsetX;
				    y = ev.offsetY;
				}
				mousePos = [ x, y ];
			}

			function handleMouseDown() {
				if (gameState == GameState.ORBIT_PLACING) {
					gameState = GameState.ORBIT_WINDUP;
					mouseDownPos = mousePos;
				}
			}

			function handleMouseUp() {
				var lengthScale = 0.05;
				if (gameState == GameState.ORBIT_WINDUP) {
					gameState = GameState.ORBIT_PLACING;

					var dir = direction(mousePos, mouseDownPos);
					var len = Math.min(distance(mousePos, mouseDownPos) * lengthScale, maxLength);
					thrownObject.vel = [ dir[0] * len, dir[1] * len ];
					mouseDownPos = [ 0, 0 ];

					thrownObjects.push(thrownObject);
					thrownObject = {
						radius : 7,
						pos : [ 0, 0 ],
						vel : [ 0, 0 ],
						active : true
					};
				}
			}

			function handleWindowResize() {
				var canvas = document.getElementById('gameBoard');
				canvas.width = window.innerWidth - 13;
 				canvas.height = window.innerHeight - 13;
			}

			function initializeGameVars() {
				gameState = GameState.ORBIT_PLACING;
				planetsLeft = 5;
				mousePos = [ -20, -20 ];
				mouseDownPos = [ 0, 0 ];
				maxLength = 80;
				maxDistance = 2000;
				iterations = 0;

				// Initialize the game objects.
				thrownObject = {
					radius : 7,
					pos : [ 0, 0 ],
					vel : [ 0, 0 ],
					active : true
				};
				thrownObjects =[];
			}

			function startGame() {
				var canvas = document.getElementById('gameBoard');
				canvas.width = window.innerWidth - 13;
 				canvas.height = window.innerHeight - 13;
 				fadeIn(canvas);

 				initializeGameVars();

 				planet.pos = [ canvas.width / 2 - planet.radius / 2, canvas.height / 2 - planet.radius / 2 ];

 				// Load the planet image.
 				var planetImage = new Image();
 				planetImage.src = "sun.png";
 				planetImage.onload = function() {
 					planet.img = planetImage;
 				}

				var context = canvas.getContext('2d');
				
				canvas.addEventListener('mousemove', handleMouseMove, false);
				canvas.addEventListener('mousedown', handleMouseDown, false);
				canvas.addEventListener('mouseup', handleMouseUp, false);
				window.onresize = handleWindowResize;

				var gameLoop = function() {
					update();
					draw(context);
				}

				var animFrameLoop = function() {
					gameLoop();
					requestAnimFrame(animFrameLoop)
				}
				requestAnimFrame(animFrameLoop);
			}
		</script>
	</head>
	<body onload="startGame();" bgcolor="black" style="margin-left:0px; margin-top:0px;">
		<div style="font-family:Helvetica; align:center;">
			<div id="scoreContainer" style="position:absolute; top:15px; left:15px; opacity:0; text-align:right;">
				<div id="highScore" style="color:white; font-size:55px; font-family:Impact;"></div>
				<!--<div id="highScoreLabel" style="font-size:14; font-weight:condensed; top:65px; background-color:#ffffff; text-align:center;">Orbiting</div>-->
				<div id="planetsLeft" style="color:white; font-size:55px; font-family:Impact;"></div>
			</div>
			<canvas id="gameBoard" width="500" height="500" style="border-width:2px; border-color:white; opacity:0;"></canvas>
		</div>
	</body>
</html>